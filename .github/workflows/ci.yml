name: CI
description: |
  Includes the whole CI pipeline.
  First creates a new nix cache, if no matching one exists.
  Then runs different checks 

permissions:
  contents: read

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}@${{ github.head_ref || github.ref }}
  cancel-in-progress: true

jobs:
  
  # Build the cache once per triggered workflow (if it doesn't exist).
  # Every workflow, which needs the nix environment, needs to depend on this job.
  # That's why the audit workflow is not simply triggered by push/pull_request, but
  # instead called by this workflow.
  # Else the nix cache might try to build two times simutaniously.
    
  build-cache-nix:
    uses: ./.github/workflows/nix-cache.yml

  audit:
    uses: ./.github/workflows/audit.yml
    needs: build-cache-nix

  backend-checks:
    uses: ./.github/workflows/run-in-nix-env.yml
    needs: build-cache-nix
    strategy:
      fail-fast: false
      matrix:
        context:
          [
            # [cargo command, requires database?]
            ["fmt -- --check", false],
            ["clippy -- -D warnings --allow clippy::needless_return", false],
            ["test", true, 'backend/'],
          ]
    with:
      commands: |
        # $\{{ case(matrix.context[1] == true, 'db-start') }} # doesnt work yet (at least with act)
        db-start
        cargo ${{ matrix.context[0] }}
      working-directory: backend/

  frontend-checks:
    uses: ./.github/workflows/run-in-nix-env.yml
    needs: build-cache-nix
    strategy:
      fail-fast: false
      matrix:
        context:
          [
            ["lint"],
            ["typecheck"],
            ["build"]
          ]
    with:
      commands: |
        npm ci
        npm run ${{ matrix.context[0] }}
      working-directory: frontend/
